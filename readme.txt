
создатель: https://vk.com/kvark_vk
//МАРУДА ЮРИЙ
//BY K`VARK

Программа для форматирования в код для машины тьюринга.
Конвертирует данный формат в формат для выполенения на эмуляторе turing_onishchenko.exe

Доступно:
-комментарии (многострочные и однострочные)
-создание массивов
-создание массивов на основе старых
-уничтожение лишних пробелов, табуляций и пропусков

 -----------------------------------------------------------
 *  пустой символ(изменить нельзя)
 доступные символы для имен переменных и состояний:
 _ , q, w, e, r, t, y, u, i, o, p,
 a, s, d, f, g, h, j, k, l, 
 z, x, c, v, b, n, m, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0

 Избегайте конфликтов имен переменных и алфавитов
 Весь регистр приводится в нижний. ТО есть имена cAkBB и cakbb - одинаковые 
 ----------------------------------------------------------
 формат файла:
 [
	//создание алфавитов
  value:4: a = (2, 4, k, n)
 ]
 {
	//сама машина тьюринга
	q1, a: q2, b , L
	q1, c: q2, c , L
 }
 ---------------------------------------------------------------

 Комментарии
	//это однострочный комментарий
//и это
				///////вооьще говоря, колво табуляций и пробелов совсем не важно
/*
	это
		коммент
			многострочный. но важно, чтобы он открывался и закрывался на отдельных строках
*/
 ----------------------------------------------------------------------

массивы:
Набор символов, которые конвертируются в группу команд:
существует три типа переменных:
value:size: - переменные
state:size: - состояния
move:size: - перемещение (только L, S, R)

использовать каждый тип переменных можно только по назначению:
state1, value1:state2, value2, move1

например:
[
state:3: a = (q1, q2, q3)
value:2: v = (k, b) //если будет v = (a, b), то "a" считается как обычная переменная типа value
state:3: a2 = (q11, q22, q33)
move:2: mov = (S, L)
]
{
	a, el_2:b, c, R //разбиение на 3 команды по "а" 
	a,   el: b, v, R  // ошибка! 
	a,   el: b, v, mov //разбиение по mov
	a,    m: a2, m, L //замена состояний(можно заменять переменные)(возможно только при одинаковой длинне заменяемых массивов, иначе ошибка)
}
Значит, можно использовать массивы только по одному в одной команде или по 2 для замены.
если массив используется не по назначению, то конвертер просто проигнорирует такой массив в команде
то есть всё это конвертируется в:
q1, el_2:b, c, R
q2, el_2:b, c, R
q3, el_2:b, c, R

a,   el: b, v, S
a,   el: b, v, L

q1,    m: q11, m, L
q2,    m: q22, m, L
q3,    m: q33, m, L

Конвертация происходит за один проход. То есть вложенные массивы создавать не получится
state:3: a = (1, 2, 3)
state:4: b = (a, m)//массив не будет считатся за вложенный

Арифметика массивов:
(можно проводить только в блоке [])
Мофификация:
value:4: a = (1, 2, 3, е)
value:4: b = a + "_n"

//теперь b = (1_n, 2_n, 3_n, е_n)
//для этой операции тип и длинна должны совпадать

 -----------------------------------------------------------------------------
файл config.txt
там задается название файла, который нужно сожрать.(FileToLoad)
а так же название готового файла выдачи (FileToGenerate)
изменять можно только название файлов.
Если в формате выходного файла будт задан .cmd
то программа сгенерирует сразу файл для выполнения на емуляторе Онищенка
иначе будет сгенерирован файл в текстовом режиме

------------------------------------------------------------------------------

Возможны ошибки работы. так же возможно не срабатывание алгоритмов на детекцию
ошибок синтаксиса или конфликтов имен. 
программа укажет на довственные команды ипа:
a, b:c, d, R
a, b:e, f, R

Строки ошибки определяются не точно.